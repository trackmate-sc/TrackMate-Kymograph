/*-
 * #%L
 * Fiji distribution of ImageJ for the life sciences.
 * %%
 * Copyright (C) 2010 - 2021 Fiji developers.
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * #L%
 */

package fiji.plugin.trackmate.kymograph.path;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.DoubleStream;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.math3.stat.StatUtils;
import org.scijava.util.ColorRGB;

import ij.ImagePlus;
import ij.measure.Calibration;
import net.imglib2.algorithm.tree.Tree;

/**
 * This class represents a traced segment (i.e., a <i>Path</i>) in a
 * reconstruction. It has methods to manipulate its points (nodes) with
 * sup-pixel accuracy, including drawing them onto threePane-style canvases,
 * etc.
 * <p>
 * Paths are non-branching sequences of adjacent points (including diagonals) in
 * the image. Branches and joins are supported by attributes of paths that
 * specify that they begin on (or end on) other paths.
 * </p>
 * <p>
 * In SNT, a Path can exist in two versions or flavors: itself and a fitted
 * version generated by {@link PathFitter}. Because fitting may fail around
 * certain nodes, the fitted version may have a different number of nodes
 * relatively to its unfitted version
 * </p>
 **/
public class Path implements Comparable< Path >
{

	// http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html
	/**
	 * Flag specifying the SWC type 'undefined'. @see Path#SWC_UNDEFINED_LABEL
	 */
	public static final int SWC_UNDEFINED = 0;

	/** Flag specifying the SWC type 'soma'. @see Path#SWC_SOMA_LABEL */
	public static final int SWC_SOMA = 1;

	/** Flag specifying the SWC type 'axon'. @see Path#SWC_AXON_LABEL */
	public static final int SWC_AXON = 2;

	/**
	 * Flag specifying the SWC type '(basal) dendrite'. @see
	 * Path#SWC_DENDRITE_LABEL
	 */
	public static final int SWC_DENDRITE = 3;

	/**
	 * Flag specifying the SWC type 'apical dendrite'. @see
	 * Path#SWC_APICAL_DENDRITE_LABEL
	 */
	public static final int SWC_APICAL_DENDRITE = 4;

	/**
	 * Flag specifying the SWC type 'fork point' @see Path#SWC_FORK_POINT_LABEL
	 */
	@Deprecated
	public static final int SWC_FORK_POINT = 5; // redundant

	@Deprecated
	/**
	 * Flag specifying the SWC type 'end point'. @see Path#SWC_END_POINT_LABEL
	 */
	public static final int SWC_END_POINT = 6; // redundant

	/** Flag specifying the SWC type 'custom'. @see Path#SWC_CUSTOM_LABEL */
	public static final int SWC_CUSTOM = 7;

	/** String representation of {@link Path#SWC_UNDEFINED} */
	public static final String SWC_UNDEFINED_LABEL = "undefined";

	/** String representation of {@link Path#SWC_SOMA} */
	public static final String SWC_SOMA_LABEL = "soma";

	/** String representation of {@link Path#SWC_AXON} */
	public static final String SWC_AXON_LABEL = "axon";

	/** String representation of {@link Path#SWC_DENDRITE} */
	public static final String SWC_DENDRITE_LABEL = "(basal) dendrite";

	/** String representation of {@link Path#SWC_APICAL_DENDRITE} */
	public static final String SWC_APICAL_DENDRITE_LABEL = "apical dendrite";

	/** String representation of {@link Path#SWC_FORK_POINT} */
	public static final String SWC_FORK_POINT_LABEL = "fork point";

	/** String representation of {@link Path#SWC_END_POINT} */
	public static final String SWC_END_POINT_LABEL = "end point";

	/** String representation of {@link Path#SWC_CUSTOM} */
	public static final String SWC_CUSTOM_LABEL = "custom";

	// FIXME: this should be based on distance between points in the path, not a
	// static number:
	protected static final int noMoreThanOneEvery = 2;

	private static final Color DEFAULT_SELECTED_COLOR = Color.GREEN;

	private static final Color DEFAULT_DESELECTED_COLOR = Color.MAGENTA;

	/* Path properties */
	// n. of nodes
	private int points;

	// node coordinates
	protected double[] precise_x_positions;

	protected double[] precise_y_positions;

	protected double[] precise_z_positions;

	// radii and tangents
	protected double[] radii;

	protected double[] tangents_x;

	protected double[] tangents_y;

	protected double[] tangents_z;

	// numeric properties of nodes (e.g., pixel intensities)
	private double[] nodeValues;

	/*
	 * Path identifiers: this Path's id is stored in (lower) bits 15-0. Tree id
	 * in the (upper) bits 31-16. NB: should only be assigned by
	 * PathAndFillManager. NB: A regular path should have a path ID > 0, because
	 * if present, its fitted version will have an ID of -path ID. see {@link
	 * #setFitted(Path)}
	 */
	private long id = -1l;

	private String treeLabel;

	// NB: The leagacy 3D viewer requires always a unique name
	private String name;

	// Path based ordering akin of reverse Horton-Strahler numbers
	private int order = 1;

	// The SWC-type flag of this path
	int swcType = SWC_UNDEFINED;

	// is this path selected in the UI?
	private boolean selected;

	// the node being edited when in 'Analysis mode'
	private int editableNodeIndex = -1;

	// the display offset for this Path in a tracing canvas
	protected PointInCanvas canvasOffset = new PointInCanvas( 0, 0, 0 );

	// the channel and frame associated with this Path (1-based indices)
	private final int[] ctPosition;

	// the number of spines or varicosities associated with this path
	private int spinesOrVaricosities;

	/* Spatial calibration definitions */
	protected double x_spacing;

	protected double y_spacing;

	protected double z_spacing;

	protected String spacing_units;

	/* Branching */
	protected Path startJoins;

	protected PointInImage startJoinsPoint = null;

	protected Path endJoins;

	protected PointInImage endJoinsPoint = null;

	// This is a symmetrical relationship, showing
	// all the other paths this one is joined to...
	protected ArrayList< Path > somehowJoins;

	// We sometimes impose a tree structure on the Path
	// graph, which is largely for display purposes. When
	// this is done, we regerated this list. This should
	// always be a subset of 'somehowJoins'...
	protected ArrayList< Path > children;

	/* Fitting (Path refinement) */
	// If this path has a fitted version, this is it
	protected Path fitted;

	// Prefer the fitted flavor of this path
	private boolean useFitted;

	// If this path is a fitted version of another one, this is the original
	protected Path fittedVersionOf;

	/* Color definitions */
	private Color color;

	private boolean hasCustomColor;

	private Color[] nodeColors;

	/* Internal fields */
	private static final int PATH_START = 0;

	private static final int PATH_END = 1;

	private static final boolean drawDiametersXY = false;

	private int maxPoints;

	/**
	 * Instantiates a new path under default settings (isotropic 1um pixel
	 * spacing)
	 */
	public Path()
	{
		this( 1, 1, 1, "um" );
	}

	/**
	 * Instantiates a new path.
	 *
	 * @param x_spacing
	 *            Pixel width in spacing_units
	 * @param y_spacing
	 *            Pixel height in spacing_units
	 * @param z_spacing
	 *            Pixel depth in spacing_units
	 * @param spacing_units
	 *            the length unit in physical world units (typically "um").
	 */
	public Path( final double x_spacing, final double y_spacing,
			final double z_spacing, final String spacing_units )
	{
		this( x_spacing, y_spacing, z_spacing, spacing_units, 128 );
	}

	Path( final double x_spacing, final double y_spacing, final double z_spacing,
			final String spacing_units, final int reserve )
	{
		this.x_spacing = x_spacing;
		this.y_spacing = y_spacing;
		this.z_spacing = z_spacing;
		this.spacing_units = spacing_units;
		points = 0;
		maxPoints = reserve;
		precise_x_positions = new double[ maxPoints ];
		precise_y_positions = new double[ maxPoints ];
		precise_z_positions = new double[ maxPoints ];
		somehowJoins = new ArrayList<>();
		children = new ArrayList<>();
		ctPosition = new int[] { 1, 1 };
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 */
	@Override
	public int compareTo( final Path o )
	{
		return Long.compare( id, o.id );
	}

	/**
	 * Gets the identifier of this Path
	 *
	 * @return the identifier
	 */
	public int getID()
	{
		return ( int ) id; // (lower) bits 15-0
	}

	/**
	 * Gets the identifier of the {@link Tree} associated to this Path (if any).
	 *
	 * @return the Tree identifier
	 */
	public int getTreeID()
	{
		return ( int ) ( id >> 32 ); // (upper) bits 31-16
	}

	protected void setIDs( final int pathID, final int treeID )
	{
		// pathID to fill lower bits, treeID to fill upper bits
		id = ( ( ( long ) treeID ) << 32 ) | ( pathID & 0xffffffffL );
	}

	protected void setTreeLabel( final String treeLabel )
	{
		this.treeLabel = treeLabel;
	}

	public String getTreeLabel()
	{
		return ( treeLabel == null ) ? "Cell " + getTreeID() : treeLabel;
	}

	/**
	 * Specifies a translation offset when rendering this Path in a
	 * {@link TracerCanvas}. Path coordinates remain unaltered.
	 *
	 * @param canvasOffset
	 *            the x,y,z coordinates (pixel-based) specifying the translation
	 *            offset
	 */
	public void setCanvasOffset( final PointInCanvas canvasOffset )
	{
		this.canvasOffset = canvasOffset;
		if ( getFitted() != null )
			getFitted().setCanvasOffset( canvasOffset );
	}

	/**
	 * Returns the translation offset used to render this Path in a
	 * {@link TracerCanvas}.
	 *
	 * @return the rendering offset (in pixel coordinates)
	 */
	public PointInCanvas getCanvasOffset()
	{
		canvasOffset.onPath = this;
		return canvasOffset;
	}

	public Path getStartJoins()
	{
		return startJoins;
	}

	public PointInImage getStartJoinsPoint()
	{ // TODO: this should be renamed?
		return startJoinsPoint;
	}

	public Path getEndJoins()
	{
		return endJoins;
	}

	public PointInImage getEndJoinsPoint()
	{
		return endJoinsPoint;
	}

	/**
	 * Sets this Path's name. Set it to null or {@code ""}, to reset it to the
	 * default.
	 *
	 * @param newName
	 *            the new name.
	 * @see #getName()
	 */
	public void setName( final String newName )
	{
		this.name = newName;
		getName(); // assign default if newName is null
	}

	/**
	 * Gets this Path's name.
	 *
	 * @return the name. If no name as been set, the default name is returned.
	 * @see #setName(String)
	 */
	public String getName()
	{
		if ( name == null || name.isEmpty() )
			name = "Path " + getID();
		return name;
	}

	protected static String pathsToIDListString( final ArrayList< Path > a )
	{
		final StringBuilder s = new StringBuilder();
		final int n = a.size();
		for ( int i = 0; i < n; ++i )
		{
			s.append( a.get( i ).getID() );
			if ( i < n - 1 )
			{
				s.append( "," );
			}
		}
		return s.toString();
	}

	protected String somehowJoinsAsString()
	{
		return pathsToIDListString( somehowJoins );
	}

	protected String childrenAsString()
	{
		return pathsToIDListString( children );
	}

	protected void setChildren( final Set< Path > pathsLeft )
	{
		// Set the children of this path in a breadth first fashion:
		children.clear();
		for ( final Path c : somehowJoins )
		{
			if ( pathsLeft.contains( c ) )
			{
				children.add( c );
				pathsLeft.remove( c );
			}
		}
		for ( final Path c : children )
			c.setChildren( pathsLeft );
	}

	/**
	 * Returns the ratio between the "Euclidean distance" of this path and its
	 * length. The Euclidean distance of this path is defined as the distance
	 * between this Path's start and end point.
	 *
	 * @return the Contraction of this Path, or {@code NaN} if this Path has no
	 *         length
	 */
	public double getContraction()
	{
		final double length = getLength();
		if ( length == 0 )
			return Double.NaN;
		final double eDistance = getNode( size() - 1 ).distanceTo( getNode( 0 ) );
		return eDistance / length;
	}

	/**
	 * Gets the length of this Path
	 *
	 * @return the length of this Path
	 */
	public double getLength()
	{
		double totalLength = 0;
		for ( int i = 1; i < points; ++i )
		{
			final double xdiff = precise_x_positions[ i ] - precise_x_positions[ i - 1 ];
			final double ydiff = precise_y_positions[ i ] - precise_y_positions[ i - 1 ];
			final double zdiff = precise_z_positions[ i ] - precise_z_positions[ i - 1 ];
			totalLength += Math.sqrt( xdiff * xdiff + ydiff * ydiff + zdiff * zdiff );
		}
		return totalLength;
	}

	protected String getRealLengthString()
	{
		return String.format( "%.3f", getLength() );
	}

	protected void createCircles()
	{
		if ( tangents_x != null || tangents_y != null || tangents_z != null ||
				radii != null )
			throw new IllegalArgumentException(
					"Trying to create circles data arrays when at least one is already there" );
		tangents_x = new double[ maxPoints ];
		tangents_y = new double[ maxPoints ];
		tangents_z = new double[ maxPoints ];
		radii = new double[ maxPoints ];
	}

	protected void setIsPrimary( final boolean primary )
	{
		if ( primary )
			setOrder( 1 );
	}

	/**
	 * Checks if this Path is root.
	 *
	 * @return true, if is primary (root)
	 */
	public boolean isPrimary()
	{
		return order == 1 || ( startJoins == null && endJoins == null );
	}

	/*
	 * We call this if we're going to delete the path represented by this object
	 */
	protected void disconnectFromAll()
	{
		/*
		 * This path can be connected to other ones either if: - this starts on
		 * other - this ends on other - other starts on this - other ends on
		 * this In any of these cases, we need to also remove this from other's
		 * somehowJoins and other from this's somehowJoins.
		 */
		for ( final Path other : somehowJoins )
		{
			if ( other.startJoins == this )
			{
				other.startJoins = null;
				other.startJoinsPoint = null;
			}
			if ( other.endJoins == this )
			{
				other.endJoins = null;
				other.endJoinsPoint = null;
			}
			final int indexInOtherSomehowJoins = other.somehowJoins.indexOf( this );
			if ( indexInOtherSomehowJoins >= 0 )
				other.somehowJoins.remove(
						indexInOtherSomehowJoins );
		}
		somehowJoins.clear();
		startJoins = null;
		startJoinsPoint = null;
		endJoins = null;
		endJoinsPoint = null;
		setIsPrimary( true );
	}

	public void setStartJoin( final Path other, final PointInImage joinPoint )
	{
		setJoin( PATH_START, other, joinPoint );
	}

	public void setEndJoin( final Path other, final PointInImage joinPoint )
	{
		setJoin( PATH_END, other, joinPoint );
	}

	/*
	 * This should be the only method that links one path to another
	 */
	protected void setJoin( final int startOrEnd, final Path other,
			final PointInImage joinPoint )
	{
		if ( other == null )
		{ throw new IllegalArgumentException(
				"setJoin should never take a null path" ); }
		if ( startOrEnd == PATH_START )
		{
			// If there was an existing path, that's an error:
			if ( startJoins != null )
				throw new IllegalArgumentException(
						"setJoin for START should not replace another join" );
			startJoins = other;
			startJoinsPoint = joinPoint;
			startJoinsPoint.onPath = this;
		}
		else if ( startOrEnd == PATH_END )
		{
			if ( endJoins != null )
				throw new IllegalArgumentException(
						"setJoin for END should not replace another join" );
			endJoins = other;
			endJoinsPoint = joinPoint;
			endJoinsPoint.onPath = this;
		}
		else
		{
			System.err.println( "BUG: unknown first parameter to setJoin" );
		}
		// Also update the somehowJoins list:
		if ( somehowJoins.indexOf( other ) < 0 )
		{
			somehowJoins.add( other );
		}
		if ( other.somehowJoins.indexOf( this ) < 0 )
		{
			other.somehowJoins.add( this );
		}
		// update order
		setOrder( other.order + 1 );
	}

	public void rebuildConnectionsOfFittedVersion()
	{
		if ( fitted == null )
			return;
		if ( isPrimary() )
		{
			fitted.disconnectFromAll();
			return;
		}
		if ( getStartJoins() != null )
		{
			if ( fitted.startJoins != null )
				fitted.unsetStartJoin();
			if ( startJoins.getUseFitted() )
			{
				final int index = startJoins.fitted.indexNearestTo( startJoinsPoint.x, startJoinsPoint.y, startJoinsPoint.z );
				final PointInImage pim = ( index == -1 ) ? startJoinsPoint : startJoins.fitted.getNodeWithoutChecks( index );
				fitted.setStartJoin( startJoins.getFitted(), pim );
			}
			else
			{
				fitted.setStartJoin( startJoins, startJoinsPoint );
			}
//			System.out.println(fitted.getName() + " connected to " + fitted.getStartJoins().getName());
//			System.out.println("        fitted.startJoinsPoint.onPath: " + fitted.startJoinsPoint.onPath.getName());

		}
		if ( getEndJoins() != null )
		{
			if ( fitted.endJoins != null )
				fitted.unsetEndJoin();

			if ( endJoins.getUseFitted() )
			{
				final int index = endJoins.fitted.indexNearestTo( endJoinsPoint.x, endJoinsPoint.y, endJoinsPoint.z );
				final PointInImage pim = ( index == -1 ) ? endJoinsPoint : endJoins.fitted.getNodeWithoutChecks( index );
				fitted.setEndJoin( endJoins.getFitted(), pim );
			}
			else
			{
				fitted.setEndJoin( endJoins, endJoinsPoint );
			}
		}

		// FIXME: This shouldn't be needed!?
		final HashSet< Path > children = new HashSet< Path >();
		for ( final Path child : getChildren() )
		{
			children.add( ( child.getUseFitted() ) ? child.getFitted() : child );
		}
		fitted.setChildren( children );

	}

	public void unsetStartJoin()
	{
		unsetJoin( PATH_START );
	}

	public void unsetEndJoin()
	{
		unsetJoin( PATH_END );
	}

	private void unsetJoin( final int startOrEnd )
	{
		Path other;
		Path leaveAloneJoin;
		if ( startOrEnd == PATH_START )
		{
			other = startJoins;
			leaveAloneJoin = endJoins;
		}
		else
		{
			other = endJoins;
			leaveAloneJoin = startJoins;
		}
		if ( other == null )
		{ throw new IllegalArgumentException(
				"Don't call unsetJoin if the other Path is already null" ); }
		if ( !( other.startJoins == this || other.endJoins == this ||
				leaveAloneJoin == other ) )
		{
			somehowJoins.remove( other );
			other.somehowJoins.remove( this );
		}
		if ( startOrEnd == PATH_START )
		{
			startJoins = null;
			startJoinsPoint = null;
		}
		else
		{
			endJoins = null;
			endJoinsPoint = null;
		}
		setOrder( -1 );
	}

	protected double getMinimumSeparation()
	{
		return Math.min( Math.abs( x_spacing ), Math.min( Math.abs( y_spacing ), Math.abs(
				z_spacing ) ) );
	}

	/**
	 * Returns the number of nodes of this path
	 *
	 * @return the size, i.e., number of nodes
	 */
	public int size()
	{
		return points;
	}

	protected void getPointDouble( final int i, final double[] p )
	{
		if ( ( i < 0 ) || i >= size() )
		{ throw new IndexOutOfBoundsException(
				"BUG: getPointDouble was asked for an out-of-range point: " + i ); }

		p[ 0 ] = precise_x_positions[ i ];
		p[ 1 ] = precise_y_positions[ i ];
		p[ 2 ] = precise_z_positions[ i ];
	}

	/**
	 * Gets the node at the specified position.
	 *
	 * @param pos
	 *            the position index (0-based). NB: You can use -1 to retrieve
	 *            the last node in the Path
	 * @return the node
	 * @throws IndexOutOfBoundsException
	 *             if position is out-of-range
	 */
	public PointInImage getNode( final int pos ) throws IndexOutOfBoundsException
	{
		if ( pos == -1 )
			return getNodeWithoutChecks( size() - 1 );
		if ( ( pos < 0 ) || pos >= size() )
		{ throw new IndexOutOfBoundsException(
				"getNode() was asked for an out-of-range point: " + pos ); }
		return getNodeWithoutChecks( pos );
	}

	/**
	 * Gets the nodes of this path.
	 *
	 * @return the list of nodes that form this path
	 */
	public List< PointInImage > getNodes()
	{
		final List< PointInImage > list = new ArrayList<>( size() );
		for ( int i = 0; i < size(); i++ )
		{
			list.add( getNodeWithoutChecks( i ) );
		}
		return list;
	}

	protected PointInImage getNodeWithoutChecks( final int pos )
	{
		final PointInImage result = new PointInImage( precise_x_positions[ pos ],
				precise_y_positions[ pos ], precise_z_positions[ pos ] );
		result.onPath = this;
		if ( nodeValues != null )
			result.v = nodeValues[ pos ];
		return result;
	}

	protected PointInCanvas getPointInCanvas( final int node )
	{
		final PointInCanvas result = new PointInCanvas( getXUnscaledDouble( node ), getYUnscaledDouble( node ),
				getZUnscaledDouble( node ) );
		result.onPath = this;
		return result;
	}

	protected PointInCanvas getPointInCanvas2D( final int node, final TracerCanvas canvas )
	{
		final PointInCanvas result;
		switch ( canvas.getPlane() )
		{
		case MultiDThreePanes.XZ_PLANE:
			result = new PointInCanvas( getXUnscaledDouble( node ), getZUnscaledDouble( node ), 0 );
			break;
		case MultiDThreePanes.ZY_PLANE:
			result = new PointInCanvas( getZUnscaledDouble( node ), getYUnscaledDouble( node ), 0 );
			break;
		default:
			result = new PointInCanvas( getXUnscaledDouble( node ), getYUnscaledDouble( node ), 0 );
			break;
		}
		result.onPath = this;
		return result;
	}

	protected List< PointInCanvas > getUnscaledNodesInViewPort( final TracerCanvas canvas )
	{
		final BoundingBox box = canvas.getViewPort();
		final List< PointInCanvas > nodes = new ArrayList<>();
		for ( int i = 0; i < size(); i++ )
		{
			final PointInCanvas node = getPointInCanvas2D( i, canvas );
			if ( box.contains( node ) )
				nodes.add( node );
		}
		return nodes;
	}

	protected boolean containsUnscaledNodesInViewPort( final TracerCanvas canvas )
	{
		final BoundingBox box = canvas.getViewPort();
		for ( int i = 0; i < size(); i++ )
		{
			final PointInCanvas node = getPointInCanvas2D( i, canvas );
			if ( box.contains( node ) )
				return true;
		}
		return false;
	}

	/**
	 * Check whether this Path contains the specified point
	 *
	 * @param pim
	 *            the {@link PointInImage} node
	 * @return true, if successful
	 */
	public boolean contains( final PointInImage pim )
	{
		if ( pim.onPath != null )
			return pim.onPath == this;
		return ( DoubleStream.of( precise_x_positions ).anyMatch( x -> x == pim.x ) &&
				DoubleStream.of( precise_y_positions ).anyMatch( y -> y == pim.y ) &&
				DoubleStream.of( precise_z_positions ).anyMatch( z -> z == pim.z ) );
	}

	/**
	 * Inserts a node at a specified position.
	 *
	 * @param index
	 *            the (zero-based) index of the position of the new node
	 * @param point
	 *            the node to be inserted
	 * @throws IllegalArgumentException
	 *             if index is out-of-range
	 */
	public void insertNode( final int index, final PointInImage point )
	{
		if ( index < 0 || index > size() )
			throw new IllegalArgumentException(
					"addNode() asked for an out-of-range point: " + index );

		// FIXME: This all would be much easier if we were using
		// Collections/Lists
		precise_x_positions = ArrayUtils.insert( index, precise_x_positions,
				point.x );
		precise_y_positions = ArrayUtils.insert( index, precise_y_positions,
				point.y );
		precise_z_positions = ArrayUtils.insert( index, precise_z_positions,
				point.z );
		points++;
		if ( hasRadii() )
		{
			tangents_x = ArrayUtils.insert( index, tangents_x, 0d );
			tangents_y = ArrayUtils.insert( index, tangents_y, 0d );
			tangents_z = ArrayUtils.insert( index, tangents_z, 0d );
			radii = ArrayUtils.insert( index, radii, 0d );
		}
		if ( nodeValues != null )
		{
			nodeValues = ArrayUtils.insert( index, nodeValues, Double.NaN );
		}
	}

	/**
	 * Removes the specified node if this path has at least two nodes. Does
	 * nothing if this is a single point path.
	 *
	 * @param index
	 *            the zero-based index of the node to be removed
	 * @throws IllegalArgumentException
	 *             if index is out-of-range
	 */
	public void removeNode( final int index )
	{
		if ( points == 1 )
			return;
		if ( index < 0 || index >= points )
			throw new IllegalArgumentException(
					"removeNode() asked for an out-of-range point: " + index );
		// FIXME: This all would be much easier if we were using
		// Collections/Lists
		final PointInImage p = getNodeWithoutChecks( index );
		precise_x_positions = ArrayUtils.remove( precise_x_positions, index );
		precise_y_positions = ArrayUtils.remove( precise_y_positions, index );
		precise_z_positions = ArrayUtils.remove( precise_z_positions, index );
		points -= 1;
		if ( hasRadii() )
		{
			tangents_x = ArrayUtils.remove( tangents_x, index );
			tangents_y = ArrayUtils.remove( tangents_y, index );
			tangents_z = ArrayUtils.remove( tangents_z, index );
			radii = ArrayUtils.remove( radii, index );
		}
		if ( nodeValues != null )
		{
			nodeValues = ArrayUtils.remove( nodeValues, index );
		}
		if ( p.equals( startJoinsPoint ) )
			startJoinsPoint = getNodeWithoutChecks( 0 );
		if ( p.equals( endJoinsPoint ) && points > 0 )
			endJoinsPoint = getNodeWithoutChecks(
					points - 1 );
	}

	/**
	 * Assigns a new location to the specified node.
	 *
	 * @param index
	 *            the zero-based index of the node to be modified
	 * @param destination
	 *            the new node location
	 * @throws IllegalArgumentException
	 *             if index is out-of-range
	 */
	public void moveNode( final int index, final PointInImage destination )
	{
		if ( index < 0 || index >= size() )
			throw new IllegalArgumentException(
					"moveNode() asked for an out-of-range point: " + index );
		precise_x_positions[ index ] = destination.x;
		precise_y_positions[ index ] = destination.y;
		precise_z_positions[ index ] = destination.z;
	}

	/**
	 * Gets the first node index associated with the specified image
	 * coordinates. Returns -1 if no such node was found.
	 *
	 * @param pim
	 *            the image position (calibrated coordinates)
	 * @return the index of the first node occurrence or -1 if there is no such
	 *         occurrence
	 */
	public int getNodeIndex( final PointInImage pim )
	{
		for ( int i = 0; i < points; ++i )
		{
			if ( Math.abs( precise_x_positions[ i ] - pim.x ) < x_spacing && Math.abs(
					precise_y_positions[ i ] - pim.y ) < y_spacing && Math.abs(
							precise_z_positions[ i ] - pim.z ) < z_spacing )
			{ return i; }
		}
		return -1;
	}

	/**
	 * Gets the closest node associated with the specified node.
	 *
	 * @param node
	 *            location to be searched for
	 * @param within
	 *            sets the search sensitivity. E.g., Setting it to
	 *            Double.MAX_VALUE (or the image's largest dimension) will
	 *            always return a valid node.
	 * @return the closest node to the specified one or null if no such node was
	 *         found.
	 */
	public PointInImage nearestNodeTo( final PointInImage node,
			final double within )
	{
		double minimumDistanceSquared = within * within;
		PointInImage closestNode = null;
		for ( int i = 0; i < size(); ++i )
		{
			final PointInImage cNode = getNodeWithoutChecks( i );
			final double thisDistanceSquared = cNode.distanceSquaredTo( node );
			if ( thisDistanceSquared < minimumDistanceSquared )
			{
				closestNode = cNode;
				minimumDistanceSquared = thisDistanceSquared;
			}
		}
		return closestNode;
	}

	/**
	 * Gets the index of the closest node associated with the specified world
	 * coordinates.
	 *
	 * @param x
	 *            the x-coordinates (spatially calibrated image units)
	 * @param y
	 *            the y-coordinates (spatially calibrated image units)
	 * @param z
	 *            the z-coordinates (spatially calibrated image units)
	 * @param within
	 *            sets the search sensitivity. E.g., Setting it to
	 *            Double.MAX_VALUE (or the image's largest dimension) will
	 *            always return a valid index.
	 * @return the index of the closest node to the specified coordinates.
	 *         Returns -1 if no such node was found.
	 */
	public int indexNearestTo( final double x, final double y, final double z,
			final double within )
	{

		if ( size() < 1 )
			throw new IllegalArgumentException(
					"indexNearestTo called on a Path of size() = 0" );

		double minimumDistanceSquared = within * within;
		int indexOfMinimum = -1;

		for ( int i = 0; i < size(); ++i )
		{

			final double diff_x = x - precise_x_positions[ i ];
			final double diff_y = y - precise_y_positions[ i ];
			final double diff_z = z - precise_z_positions[ i ];

			final double thisDistanceSquared = diff_x * diff_x + diff_y * diff_y +
					diff_z * diff_z;

			if ( thisDistanceSquared < minimumDistanceSquared )
			{
				indexOfMinimum = i;
				minimumDistanceSquared = thisDistanceSquared;
			}
		}

		return indexOfMinimum;
	}

	protected int indexNearestToCanvasPosition2D( final double xInCanvas,
			final double yInCanvas, final double withinPixels )
	{
		double minimumDistanceSquared = withinPixels * withinPixels;
		int indexOfMinimum = -1;
		for ( int i = 0; i < size(); ++i )
		{
			final double diff_x = xInCanvas - getXUnscaledDouble( i );
			final double diff_y = yInCanvas - getYUnscaledDouble( i );
			final double thisDistanceSquared = diff_x * diff_x + diff_y * diff_y;
			if ( thisDistanceSquared < minimumDistanceSquared )
			{
				indexOfMinimum = i;
				minimumDistanceSquared = thisDistanceSquared;
			}
		}
		return indexOfMinimum;
	}

	protected int indexNearestTo( final double x, final double y, final double z )
	{
		return indexNearestTo( x, y, z, Double.MAX_VALUE );
	}

	/**
	 * Gets the position of the node tagged as 'editable', if any.
	 *
	 * @return the index of the point currently tagged as editable, or -1 if no
	 *         such point exists
	 */
	public int getEditableNodeIndex()
	{
		return editableNodeIndex;
	}

	/**
	 * Tags the specified point position as 'editable'.
	 *
	 * @param index
	 *            the index of the point to be tagged. Set it to -1 to for no
	 *            tagging
	 */
	public void setEditableNode( final int index )
	{
		this.editableNodeIndex = index;
	}

	protected boolean isBeingEdited()
	{
		return editableNodeIndex != -1;
	}

	protected void stopBeingEdited()
	{
		editableNodeIndex = -1;
	}

	public int getXUnscaled( final int i )
	{
		return ( int ) Math.round( getXUnscaledDouble( i ) );
	}

	public int getYUnscaled( final int i )
	{
		return ( int ) Math.round( getYUnscaledDouble( i ) );
	}

	public int getZUnscaled( final int i )
	{
		return ( int ) Math.round( getZUnscaledDouble( i ) );
	}

	public double getXUnscaledDouble( final int i )
	{
//		if ((i < 0) || i >= size())
//			throw new IllegalArgumentException("getXUnscaled was asked for an out-of-range point: " + i);
		return precise_x_positions[ i ] / x_spacing + canvasOffset.x;
	}

	public double getYUnscaledDouble( final int i )
	{
//		if ((i < 0) || i >= size())
//			throw new IllegalArgumentException("getYUnscaled was asked for an out-of-range point: " + i);
		return precise_y_positions[ i ] / y_spacing + canvasOffset.y;
	}

	public double getZUnscaledDouble( final int i )
	{
//		if ((i < 0) || i >= size())
//			throw new IllegalArgumentException("getZUnscaled was asked for an out-of-range point: " + i);
		return precise_z_positions[ i ] / z_spacing + canvasOffset.z;
	}

	/**
	 * Gets a section between two nodes of this Path.
	 *
	 * @param startIndex
	 *            the node index defining the first node of the section
	 * @param endIndex
	 *            the node index defining the last node of the section
	 * @return the section. Note that the sectioned Path will share of all of
	 *         this Path's properties but will not contain any information on
	 *         junction points or connectivity to other Paths.
	 */
	public Path getSection( final int startIndex, final int endIndex )
	{
		if ( startIndex < 0 || endIndex > size() || endIndex < startIndex )
		{ throw new IllegalArgumentException( "Indices out of range!" ); }
		final Calibration cal = getCalibration();
		final Path sub = new Path( cal.pixelWidth, cal.pixelHeight, cal.pixelDepth, cal.getUnit(), size() );
		sub.points = endIndex - startIndex + 1;
		sub.precise_x_positions = Arrays.copyOfRange( precise_x_positions, startIndex, endIndex + 1 );
		sub.precise_y_positions = Arrays.copyOfRange( precise_y_positions, startIndex, endIndex + 1 );
		sub.precise_z_positions = Arrays.copyOfRange( precise_z_positions, startIndex, endIndex + 1 );
		if ( radii != null )
			sub.radii = Arrays.copyOfRange( radii, startIndex, endIndex + 1 );
		if ( tangents_x != null )
			sub.tangents_x = Arrays.copyOfRange( tangents_x, startIndex, endIndex + 1 );
		if ( tangents_y != null )
			sub.tangents_y = Arrays.copyOfRange( tangents_y, startIndex, endIndex + 1 );
		if ( tangents_z != null )
			sub.tangents_z = Arrays.copyOfRange( tangents_z, startIndex, endIndex + 1 );
		if ( nodeValues != null )
			sub.nodeValues = Arrays.copyOfRange( nodeValues, startIndex, endIndex + 1 );
		if ( nodeColors != null )
			sub.nodeColors = Arrays.copyOfRange( nodeColors, startIndex, endIndex + 1 );
		if ( getFitted() != null )
			sub.setFitted( getFitted().getSection( startIndex, endIndex ) );
		applyCommonProperties( sub );
		return sub;
	}

	private void applyCommonProperties( final Path other )
	{
		other.setOrder( getOrder() );
		other.setIsPrimary( isPrimary() );
		other.setSWCType( getSWCType() );
		other.setCTposition( getChannel(), getFrame() );
		other.setEditableNode( ( getEditableNodeIndex() < other.size() ) ? getEditableNodeIndex() : -1 );
		other.setCanvasOffset( getCanvasOffset() );
		other.setColor( getColor() );
		other.setSpineOrVaricosityCount( getSpineOrVaricosityCount() );
		other.id = id;
	}

	/**
	 * Returns a new Path with this Path's attributes (e.g. spatial scale), but
	 * no nodes.
	 *
	 * @return the empty path
	 */
	public Path createPath()
	{
		final Calibration cal = getCalibration();
		final Path dup = new Path( cal.pixelWidth, cal.pixelHeight, cal.pixelDepth, cal.getUnit(), size() );
		applyCommonProperties( dup );
		return dup;
	}

	protected void setSpacing( final Calibration cal )
	{
		this.x_spacing = cal.pixelWidth;
		this.y_spacing = cal.pixelHeight;
		this.z_spacing = cal.pixelDepth;
		this.spacing_units = cal.getUnit();
	}

	@SuppressWarnings( "unchecked" )
	@Override
	public Path clone()
	{

		final Calibration cal = getCalibration();
		final Path dup = new Path( cal.pixelWidth, cal.pixelHeight, cal.pixelDepth, cal.getUnit(), size() );
		dup.points = points;
		dup.precise_x_positions = precise_x_positions.clone();
		dup.precise_y_positions = precise_y_positions.clone();
		dup.precise_z_positions = precise_z_positions.clone();
		if ( radii != null )
			dup.radii = radii.clone();
		if ( tangents_x != null )
			dup.tangents_x = tangents_x.clone();
		if ( tangents_y != null )
			dup.tangents_y = tangents_y.clone();
		if ( tangents_z != null )
			dup.tangents_z = tangents_z.clone();
		if ( nodeValues != null )
			dup.nodeValues = nodeValues.clone();
		dup.somehowJoins = ( ArrayList< Path > ) somehowJoins.clone();
		dup.children = ( ArrayList< Path > ) children.clone();
		if ( startJoins != null )
			dup.startJoins = startJoins.clone();
		if ( startJoinsPoint != null )
			dup.startJoinsPoint = startJoinsPoint.clone();
		if ( endJoins != null )
			dup.endJoins = endJoins.clone();
		if ( endJoinsPoint != null )
			dup.endJoinsPoint = endJoinsPoint.clone();
		if ( getFitted() != null )
			dup.setFitted( getFitted().clone() );
		dup.setNodeColors( getNodeColors() );
		applyCommonProperties( dup );
		return dup;
	}

	public Path clone( final boolean includeImmediateChildren )
	{
		final Path dup = clone();
		if ( !includeImmediateChildren )
			return dup;

		dup.children = new ArrayList<>( children.size() );
		final Iterator< Path > childrenIt = children.iterator();
		while ( childrenIt.hasNext() )
		{
			final Path child = childrenIt.next();
			final Path dupChild = child.clone();
			if ( dupChild.getStartJoinsPoint() != null )
			{
				final PointInImage dupSPoint = dupChild.getStartJoinsPoint().clone();
				dupChild.unsetStartJoin();
				dupChild.setStartJoin( dup, dupSPoint );
			}
			if ( dupChild.getEndJoinsPoint() != null )
			{
				final PointInImage dupEPoint = dupChild.getEndJoinsPoint().clone();
				dupChild.unsetEndJoin();
				dupChild.setEndJoin( dup, dupEPoint );
			}
			dup.children.add( dupChild );
		}
		return dup;
	}

	public ArrayList< Path > getChildren()
	{
		return children;
	}

	/**
	 * Gets the spatial calibration of this Path.
	 *
	 * @return the calibration details associated with this Path
	 */
	public Calibration getCalibration()
	{
		final Calibration cal = new Calibration();
		cal.setUnit( spacing_units );
		cal.pixelWidth = x_spacing;
		cal.pixelHeight = y_spacing;
		cal.pixelDepth = z_spacing;
		return cal;
	}

	protected PointInImage lastPoint()
	{
		if ( points < 1 )
			return null;
		else
			return new PointInImage( precise_x_positions[ points - 1 ],
					precise_y_positions[ points - 1 ], precise_z_positions[ points - 1 ] );
	}

	private void expandTo( final int newMaxPoints )
	{

		final double[] new_precise_x_positions = new double[ newMaxPoints ];
		final double[] new_precise_y_positions = new double[ newMaxPoints ];
		final double[] new_precise_z_positions = new double[ newMaxPoints ];
		System.arraycopy( precise_x_positions, 0, new_precise_x_positions, 0,
				points );
		System.arraycopy( precise_y_positions, 0, new_precise_y_positions, 0,
				points );
		System.arraycopy( precise_z_positions, 0, new_precise_z_positions, 0,
				points );
		precise_x_positions = new_precise_x_positions;
		precise_y_positions = new_precise_y_positions;
		precise_z_positions = new_precise_z_positions;
		if ( hasRadii() )
		{
			final double[] new_tangents_x = new double[ newMaxPoints ];
			final double[] new_tangents_y = new double[ newMaxPoints ];
			final double[] new_tangents_z = new double[ newMaxPoints ];
			final double[] new_radiuses = new double[ newMaxPoints ];
			System.arraycopy( tangents_x, 0, new_tangents_x, 0, points );
			System.arraycopy( tangents_y, 0, new_tangents_y, 0, points );
			System.arraycopy( tangents_z, 0, new_tangents_z, 0, points );
			System.arraycopy( radii, 0, new_radiuses, 0, points );
			tangents_x = new_tangents_x;
			tangents_y = new_tangents_y;
			tangents_z = new_tangents_z;
			radii = new_radiuses;
		}
		if ( nodeValues != null )
		{
			final double[] newNodeValues = new double[ newMaxPoints ];
			System.arraycopy( nodeValues, 0, newNodeValues, 0, points );
			nodeValues = newNodeValues;
		}
		maxPoints = newMaxPoints;
	}

	protected void add( final Path other )
	{

		if ( other == null )
		{
			System.out.println( "BUG: Trying to add null Path" );
			return;
		}

		// If we're trying to add a path with circles to one
		// that previously had none, add circles to the
		// previous one, and carry on:

		if ( other.hasRadii() && !hasRadii() )
		{
			createCircles();
			final double defaultRadius = getMinimumSeparation() * 2;
			for ( int i = 0; i < points; ++i )
				radii[ i ] = defaultRadius;
		}

		if ( maxPoints < ( points + other.points ) )
		{
			expandTo( points + other.points );
		}

		int toSkip = 0;

		/*
		 * We may want to skip some points at the beginning of the next path if
		 * they're the same as the last point on this path:
		 */
		if ( points > 0 )
		{
			final double last_x = precise_x_positions[ points - 1 ];
			final double last_y = precise_y_positions[ points - 1 ];
			final double last_z = precise_z_positions[ points - 1 ];
			while ( ( other.precise_x_positions[ toSkip ] == last_x ) &&
					( other.precise_y_positions[ toSkip ] == last_y ) &&
					( other.precise_z_positions[ toSkip ] == last_z ) )
			{
				++toSkip;
			}
		}

		System.arraycopy( other.precise_x_positions, toSkip, precise_x_positions,
				points, other.points - toSkip );
		System.arraycopy( other.precise_y_positions, toSkip, precise_y_positions,
				points, other.points - toSkip );
		System.arraycopy( other.precise_z_positions, toSkip, precise_z_positions,
				points, other.points - toSkip );

		if ( hasRadii() && other.hasRadii() )
		{
			System.arraycopy( other.radii, toSkip, radii, points, other.points -
					toSkip );
		}

		if ( endJoins != null )
			throw new IllegalArgumentException(
					"BUG: we should never be adding to a path that already endJoins" );

		if ( other.endJoins != null )
		{
			setEndJoin( other.endJoins, other.endJoinsPoint );
			other.disconnectFromAll();
		}

		points = points + ( other.points - toSkip );

		if ( hasRadii() )
		{
			setGuessedTangents( 2 );
		}
	}

	protected void unsetPrimaryForConnected( final HashSet< Path > pathsExplored )
	{
		for ( final Path p : somehowJoins )
		{
			if ( pathsExplored.contains( p ) )
				continue;
			p.setIsPrimary( false );
			pathsExplored.add( p );
			p.unsetPrimaryForConnected( pathsExplored );
		}
	}

	protected Path reversed()
	{
		final Path c = new Path( x_spacing, y_spacing, z_spacing, spacing_units,
				points );
		c.points = points;
		for ( int i = 0; i < points; ++i )
		{
			c.precise_x_positions[ i ] = precise_x_positions[ ( points - 1 ) - i ];
			c.precise_y_positions[ i ] = precise_y_positions[ ( points - 1 ) - i ];
			c.precise_z_positions[ i ] = precise_z_positions[ ( points - 1 ) - i ];
		}
		return c;
	}

	/**
	 * Appends a node to this Path.
	 *
	 * @param point
	 *            the node to be inserted
	 */
	public void addNode( final PointInImage point )
	{
		addCommonPropertiesNode( point );
		if ( !Double.isNaN( point.v ) )
			setNodeValue( point.v, size() - 1 );
		if ( point instanceof SWCPoint )
		{
			final double radius = ( ( SWCPoint ) point ).radius;
			if ( radius > 0 )
			{
				if ( !hasRadii() )
					createCircles();
				radii[ size() - 1 ] = ( ( SWCPoint ) point ).radius;
			}
		}
	}

	private void addCommonPropertiesNode( final SNTPoint point )
	{
		addPointDouble( point.getX(), point.getY(), point.getZ() );
	}

	protected void addPointDouble( final double x, final double y, final double z )
	{
		if ( points >= maxPoints )
		{
			final int newReserved = ( int ) ( maxPoints * 1.2 + 1 );
			expandTo( newReserved );
		}
		precise_x_positions[ points ] = x;
		precise_y_positions[ points ] = y;
		precise_z_positions[ points++ ] = z;
	}

	public void drawPathAsPoints( final TracerCanvas canvas, final Graphics2D g,
			final java.awt.Color c, final int plane, final boolean highContrast,
			final boolean drawDiameter )
	{
		drawPathAsPoints( canvas, g, c, plane, highContrast, drawDiameter, 0, -1 );
	}

	protected void drawPathAsPoints( final TracerCanvas canvas, final Graphics2D g,
			final java.awt.Color c, final int plane, final boolean drawDiameter,
			final int slice, final int either_side )
	{
		drawPathAsPoints( canvas, g, c, plane, false, drawDiameter, slice,
				either_side );
	}

	protected void drawPathAsPoints( final Graphics2D g2,
			final TracerCanvas canvas )
	{
		final boolean customColor = hasCustomColor;
		Color color = DEFAULT_DESELECTED_COLOR;
		if ( isSelected() && !customColor )
			color = DEFAULT_SELECTED_COLOR;
		else if ( customColor )
			color = getColor();
		final int sliceZeroIndexed = canvas.getImage().getZ() - 1;
		int eitherSideParameter = canvas.eitherSide;
		if ( !canvas.just_near_slices )
			eitherSideParameter = -1;
		drawPathAsPoints( canvas, g2, color, canvas.getPlane(), customColor,
				drawDiametersXY, sliceZeroIndexed, eitherSideParameter );
	}

	public void drawPathAsPoints( final TracerCanvas canvas, final Graphics2D g2,
			final java.awt.Color c, final int plane, final boolean highContrast,
			boolean drawDiameter, final int slice, final int either_side )
	{

		g2.setColor( c );
		g2.setStroke( new BasicStroke( ( float ) ( canvas.nodeDiameter() / 2.5 ), BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND ) );
		int startIndexOfLastDrawnLine = -1;

		if ( !hasRadii() )
			drawDiameter = false;

		for ( int i = 0; i < points; ++i )
		{

			double previous_x_on_screen = Integer.MIN_VALUE;
			double previous_y_on_screen = Integer.MIN_VALUE;
			double next_x_on_screen = Integer.MIN_VALUE;
			double next_y_on_screen = Integer.MIN_VALUE;
			final boolean notFirstPoint = i > 0;
			final boolean notLastPoint = i < points - 1;
			int slice_of_point = Integer.MIN_VALUE;

			switch ( plane )
			{
			case MultiDThreePanes.XY_PLANE:
				if ( notFirstPoint )
				{
					previous_x_on_screen = canvas.myScreenXDprecise( getXUnscaledDouble(
							i - 1 ) );
					previous_y_on_screen = canvas.myScreenYDprecise( getXUnscaledDouble(
							i - 1 ) );
				}
				if ( notLastPoint )
				{
					next_x_on_screen = canvas.myScreenXDprecise( getXUnscaledDouble( i +
							1 ) );
					next_y_on_screen = canvas.myScreenYDprecise( getYUnscaledDouble( i +
							1 ) );
				}
				slice_of_point = getZUnscaled( i );
				break;
			case MultiDThreePanes.XZ_PLANE:
				if ( notFirstPoint )
				{
					previous_x_on_screen = canvas.myScreenXDprecise( getXUnscaledDouble(
							i - 1 ) );
					previous_y_on_screen = canvas.myScreenYDprecise( getZUnscaledDouble(
							i - 1 ) );
				}
				if ( notLastPoint )
				{
					next_x_on_screen = canvas.myScreenXDprecise( getXUnscaledDouble( i +
							1 ) );
					next_y_on_screen = canvas.myScreenYDprecise( getZUnscaledDouble( i +
							1 ) );
				}
				slice_of_point = getYUnscaled( i );
				break;
			case MultiDThreePanes.ZY_PLANE:
				if ( notFirstPoint )
				{
					previous_x_on_screen = canvas.myScreenXDprecise( getZUnscaledDouble(
							i - 1 ) );
					previous_y_on_screen = canvas.myScreenYDprecise( getYUnscaledDouble(
							i - 1 ) );
				}
				if ( notLastPoint )
				{
					next_x_on_screen = canvas.myScreenXDprecise( getZUnscaledDouble( i +
							1 ) );
					next_y_on_screen = canvas.myScreenYDprecise( getYUnscaledDouble( i +
							1 ) );
				}
				slice_of_point = getXUnscaled( i );
				break;
			default:
				throw new IllegalArgumentException( "BUG: Unknown plane! (" + plane +
						")" );
			}

			final PathNode pn = new PathNode( this, i, canvas );
			final boolean outOfDepthBounds = ( either_side >= 0 ) && ( Math.abs(
					slice_of_point - slice ) > either_side );
			g2.setColor( PathNode.alphaColor( c,
					( outOfDepthBounds ) ? canvas.getOutOfBoundsTransparency() : canvas.getDefaultTransparency() ) );

			// If there was a previous point in this path, draw a line from
			// there to
			// here:
			if ( notFirstPoint )
			{
				// Don't redraw the line if we drew it the previous time,
				// though:
				if ( startIndexOfLastDrawnLine != i - 1 )
				{
					g2.draw( new Line2D.Double( previous_x_on_screen, previous_y_on_screen,
							pn.x, pn.y ) );
					startIndexOfLastDrawnLine = i - 1;
				}
			}

			// If there's a next point in this path, draw a line from here to
			// there:
			if ( notLastPoint )
			{
				g2.draw( new Line2D.Double( pn.x, pn.y, next_x_on_screen,
						next_y_on_screen ) );
				startIndexOfLastDrawnLine = i;
			}

			if ( outOfDepthBounds )
				continue; // draw nothing more for points
							// out-of-bounds

			// If we've been asked to draw the diameters, just do it in XY
			if ( drawDiameter && plane == MultiDThreePanes.XY_PLANE )
			{

				// Cross the tangents with a unit z vector:
				final double n_x = 0;
				final double n_y = 0;
				final double n_z = 1;
				final double t_x = tangents_x[ i ];
				final double t_y = tangents_y[ i ];
				final double t_z = tangents_z[ i ];
				final double cross_x = n_y * t_z - n_z * t_y;
				final double cross_y = n_z * t_x - n_x * t_z;
				// double cross_z = n_x * t_y - n_y * t_x;

				final double sizeInPlane = Math.sqrt( cross_x * cross_x + cross_y *
						cross_y );
				final double normalized_cross_x = cross_x / sizeInPlane;
				final double normalized_cross_y = cross_y / sizeInPlane;
				final double zdiff = Math.abs( ( slice - slice_of_point ) * z_spacing );
				final double realRadius = radii[ i ];

				if ( either_side < 0 || zdiff <= realRadius )
				{

					double effective_radius;
					if ( either_side < 0 )
						effective_radius = realRadius;
					else
						effective_radius = Math.sqrt( realRadius * realRadius - zdiff *
								zdiff );

					final double left_x = precise_x_positions[ i ] + normalized_cross_x *
							effective_radius;
					final double left_y = precise_y_positions[ i ] + normalized_cross_y *
							effective_radius;
					final double right_x = precise_x_positions[ i ] - normalized_cross_x *
							effective_radius;
					final double right_y = precise_y_positions[ i ] - normalized_cross_y *
							effective_radius;

					final double left_x_on_screen = canvas.myScreenXDprecise(
							canvasOffset.x + left_x / x_spacing );
					final double left_y_on_screen = canvas.myScreenYDprecise(
							canvasOffset.y + left_y / y_spacing );
					final double right_x_on_screen = canvas.myScreenXDprecise(
							canvasOffset.x + right_x / x_spacing );
					final double right_y_on_screen = canvas.myScreenYDprecise(
							canvasOffset.y + right_y / y_spacing );

					final double x_on_screen = canvas.myScreenXDprecise( canvasOffset.x +
							precise_x_positions[ i ] / x_spacing );
					final double y_on_screen = canvas.myScreenYDprecise( canvasOffset.y +
							precise_y_positions[ i ] / y_spacing );

					g2.draw( new Line2D.Double( x_on_screen, y_on_screen, left_x_on_screen,
							left_y_on_screen ) );
					g2.draw( new Line2D.Double( x_on_screen, y_on_screen, right_x_on_screen,
							right_y_on_screen ) );
				}

			}

			// Draw node
			pn.setEditable( getEditableNodeIndex() == i );
			pn.draw( g2, c );
			// g2.setColor(c); // reset color transparencies. Not really needed
		}

	}

	/**
	 * Sets the node colors.
	 *
	 * @param colors
	 *            the colors used to render the nodes of this. If null (the
	 *            default) all nodes are rendered using the Path color.
	 */
	public void setNodeColors( final Color[] colors )
	{
		if ( colors != null && colors.length != size() )
		{ throw new IllegalArgumentException(
				"colors array must have as many elements as nodes" ); }
		nodeColors = colors;
	}

	/**
	 * Gets the node colors.
	 *
	 * @return the colors used to render the nodes of this path, or null if
	 *         nodes are rendered using the Path color
	 */
	public Color[] getNodeColors()
	{
		return nodeColors;
	}

	/**
	 * Gets the node color.
	 *
	 * @param pos
	 *            the node position
	 * @return the node color, or null if no color nodes have been assigned to
	 *         this path
	 */
	public Color getNodeColor( final int pos )
	{
		return ( nodeColors == null ) ? null : nodeColors[ pos ];
	}

	/**
	 * Sets the node color.
	 *
	 * @param color
	 *            the node color
	 * @param pos
	 *            the node position
	 */
	public void setNodeColor( final Color color, final int pos )
	{
		if ( nodeColors == null )
			nodeColors = new Color[ size() ];
		nodeColors[ pos ] = color;
	}

	/**
	 * Sets the node color.
	 *
	 * @param color
	 *            the node color
	 * @param pos
	 *            the node position
	 */
	public void setNodeColor( final ColorRGB color, final int pos )
	{
		setNodeColor( ( color == null ) ? null : new Color( color.getARGB() ), pos );
	}

	/**
	 * Assigns the "value" property to this node.
	 *
	 * @param value
	 *            the node value
	 * @param pos
	 *            the node position
	 * @see PathProfiler#assignValues()
	 */
	public void setNodeValue( final double value, final int pos )
	{
		if ( nodeValues == null )
		{
			nodeValues = new double[ maxPoints ];
		}
		nodeValues[ pos ] = value;
	}

	/**
	 * Returns the "value" property of this node.
	 *
	 * @param pos
	 *            the node position
	 * @return the value property of this node
	 * @see PathProfiler#assignValues()
	 * @see PointInImage#v
	 */
	public double getNodeValue( final int pos )
	{
		return ( nodeValues == null ) ? null : nodeValues[ pos ];
	}

	/**
	 * Sets the path "values", the array containing the numeric property
	 * assigned to path nodes, typically voxel intensities.
	 *
	 * @param values
	 *            the new node values
	 * @see PointInImage#v
	 * @see PathProfiler#assignValues()
	 */
	public void setNodeValues( final double[] values )
	{
		if ( values != null && values.length != size() )
		{ throw new IllegalArgumentException(
				"values array must have as many elements as nodes" ); }
		this.nodeValues = ( values == null ) ? null : values.clone();
	}

	/**
	 * Assesses whether the nodes of this path have been assigned an array of
	 * values
	 *
	 * @return true, if successful
	 * @see PointInImage#v
	 * @see PathProfiler#assignValues()
	 */
	public boolean hasNodeValues()
	{
		return nodeValues != null;
	}

	/**
	 * Gets the color of this Path
	 *
	 * @return the color, or null if no color has been assigned to this Path
	 * @see #hasCustomColor
	 * @see #hasNodeColors()
	 */
	public Color getColor()
	{
		return color;
	}

	/**
	 * Gets the color of this Path
	 *
	 * @return the color, or null if no color has been assigned to this Path
	 * @see #hasCustomColor
	 * @see #hasNodeColors()
	 */
	public ColorRGB getColorRGB()
	{
		return ( color == null ) ? null : new ColorRGB( color.getRed(), color
				.getGreen(), color.getBlue() );
	}

	/**
	 * Sets this path color.
	 *
	 * @param color
	 *            the path color. Set it to null, to have SNT render this Path
	 *            using default settings. You may need to cast the null
	 *            reference to {@code Color} to avoid ambiguous method overload
	 */
	public void setColor( final Color color )
	{
		this.color = color;
		hasCustomColor = color != null;
		if ( getFitted() != null )
			getFitted().setColor( color );
		if ( hasNodeColors() && size() == 1 )
			nodeColors[ 0 ] = color;
	}

	/**
	 * Sets this path color.
	 *
	 * @param color
	 *            the path color. Set it to null, to have SNT render this Path
	 *            using default settings. You may need to cast the null
	 *            reference to {@code ColorRGB} to avoid ambiguous method
	 *            overload
	 */
	public void setColor( final ColorRGB color )
	{
		setColor( ( color == null ) ? null : new Color( color.getARGB() ) );
	}

	/**
	 * Resets this path color, forcing SNT to render it under default settings.
	 */
	public void resetColor()
	{
		setColor( ( Color ) null );
	}

	/**
	 * Assesses whether a custom color has been assigned to this Path.
	 *
	 * @return true, if successful
	 * @see #hasNodeColors()
	 */
	public boolean hasCustomColor()
	{
		return ( hasCustomColor && color != null ); // backwards compatibility:
													// we cannot include
													// hasNodeColors()
	}

	/**
	 * Assesses whether the nodes of this path have been assigned an array of
	 * colors
	 *
	 * @return true, if successful
	 * @see #getNodeColors()
	 */
	public boolean hasNodeColors()
	{
		return nodeColors != null;
	}

	/**
	 * Gets the default SWC colors used by SNT.
	 *
	 * @param swcType
	 *            the SEC type (e.g., {@link Path#SWC_AXON},
	 *            {@link Path#SWC_DENDRITE}, etc.)
	 * @return the SWC color
	 */
	public static Color getSWCcolor( final int swcType )
	{
		switch ( swcType )
		{
		case Path.SWC_SOMA:
			return Color.BLUE;
		case Path.SWC_DENDRITE:
			return Color.GREEN;
		case Path.SWC_APICAL_DENDRITE:
			return Color.CYAN;
		case Path.SWC_AXON:
			return Color.RED;
		case Path.SWC_FORK_POINT:
			return Color.ORANGE;
		case Path.SWC_END_POINT:
			return Color.PINK;
		case Path.SWC_CUSTOM:
			return Color.YELLOW;
		case Path.SWC_UNDEFINED:
		default:
			return DEFAULT_DESELECTED_COLOR;
		}
	}

	/**
	 * Checks if this Path is a fitted version of another path.
	 *
	 * @return true, if it is a fitted version of another path
	 */
	public boolean isFittedVersionOfAnotherPath()
	{
		return fittedVersionOf != null;
	}

	protected void setFitted( final Path p )
	{
		if ( getFitted() != null && p != null )
		{ throw new IllegalArgumentException(
				"BUG: Trying to set a fitted path when there already is one..." ); }
		fitted = p;
		if ( p == null )
		{
			setUseFitted( false );
		}
		else
		{
			p.fittedVersionOf = this;
			p.setIDs( -getID(), getTreeID() );
//			System.out.println("Just set " + p.getName() + " is a fitted version of " + getName() );
		}
	}

	/**
	 * Sets whether the fitted flavor of this Path should be used.
	 *
	 * @param useFitted
	 *            the new use fitted
	 * @throws IllegalArgumentException
	 *             if this Path has not been fitted
	 */
	public void setUseFitted( final boolean useFitted )
			throws IllegalArgumentException
	{
		if ( useFitted && getFitted() == null )
			throw new IllegalArgumentException(
					"setUseFitted(true) called, but 'fitted' member was null" );
		this.useFitted = useFitted;
	}

	protected void discardFit()
	{
		fitted = null;
		useFitted = false;
	}

	/**
	 * Gets whether the fitted 'flavor' of this Path is in use.
	 *
	 * @return true, if the fitted version of this Path is in use, otherwise
	 *         false
	 */
	public boolean getUseFitted()
	{
		return useFitted && fitted != null;
	}

	public int getSpineOrVaricosityCount()
	{
		return spinesOrVaricosities;
	}

	public void setSpineOrVaricosityCount( final int newCount )
	{
		this.spinesOrVaricosities = newCount;
		if ( fitted != null )
			fitted.setSpineOrVaricosityCount( newCount );
	}

	/**
	 * Gets the hyperstack channel associated with this Path.
	 *
	 * @return the channel position of this path (1-based index). Note that if
	 *         the channel associated with a path is not known, it is assumed to
	 *         be 1;
	 */
	public int getChannel()
	{
		return ctPosition[ 0 ];
	}

	/**
	 * Gets the hyperstack frame position associated with this Path.
	 *
	 * @return the frame position of this path (1-based index). Note that if the
	 *         frame associated with a path is not known, it is assumed to be 1;
	 */
	public int getFrame()
	{
		return ctPosition[ 1 ];
	}

	/**
	 * Sets the hyperstack position of this Path
	 *
	 * @param channel
	 *            the channel (one-based index)
	 * @param frame
	 *            the frame (one-based index)
	 */
	public void setCTposition( final int channel, final int frame )
	{
		ctPosition[ 0 ] = channel;
		ctPosition[ 1 ] = frame;
	}

	/**
	 * Gets the fitted version ('flavor') of this Path.
	 *
	 * @return the fitted version, or null if this Path has not been fitted
	 */
	public Path getFitted()
	{
		return fitted;
	}

	protected void setGuessedTangents( final int pointsEitherSide )
	{
		if ( tangents_x == null || tangents_y == null || tangents_z == null )
			throw new IllegalArgumentException(
					"BUG: setGuessedTangents called with one of the tangent arrays null" );
		final double[] tangent = new double[ 3 ];
		for ( int i = 0; i < points; ++i )
		{
			getTangent( i, pointsEitherSide, tangent );
			tangents_x[ i ] = tangent[ 0 ];
			tangents_y[ i ] = tangent[ 1 ];
			tangents_z[ i ] = tangent[ 2 ];
		}
	}

	protected void getTangent( final int i, final int pointsEitherSide,
			final double[] result )
	{
		int min_index = i - pointsEitherSide;
		if ( min_index < 0 )
			min_index = 0;

		int max_index = i + pointsEitherSide;
		if ( max_index >= points )
			max_index = points - 1;

		result[ 0 ] = precise_x_positions[ max_index ] - precise_x_positions[ min_index ];
		result[ 1 ] = precise_y_positions[ max_index ] - precise_y_positions[ min_index ];
		result[ 2 ] = precise_z_positions[ max_index ] - precise_z_positions[ min_index ];
	}

	/**
	 * Gets the list of string representations of non-redundant SWC types (i.e.,
	 * excluding {@link Path#SWC_FORK_POINT_LABEL}, and
	 * {@link Path#SWC_FORK_POINT_LABEL}
	 *
	 * @return the list of SWC type names
	 */
	public static ArrayList< String > getSWCtypeNames()
	{
		final ArrayList< String > swcTypes = new ArrayList<>();
		swcTypes.add( SWC_UNDEFINED_LABEL );
		swcTypes.add( SWC_SOMA_LABEL );
		swcTypes.add( SWC_AXON_LABEL );
		swcTypes.add( SWC_DENDRITE_LABEL );
		swcTypes.add( SWC_APICAL_DENDRITE_LABEL );
		// swcTypes.add(SWC_FORK_POINT_LABEL);
		// swcTypes.add(SWC_END_POINT_LABEL);
		swcTypes.add( SWC_CUSTOM_LABEL );
		return swcTypes;
	}

	/**
	 * Gets the list of non-redundant SWC types (i.e., excluding the redundant
	 * types {@link Path#SWC_FORK_POINT_LABEL}, and
	 * {@link Path#SWC_FORK_POINT_LABEL}
	 *
	 * @return the list of SWC type flags
	 */
	public static ArrayList< Integer > getSWCtypes()
	{
		final ArrayList< Integer > swcTypes = new ArrayList<>();
		swcTypes.add( SWC_UNDEFINED );
		swcTypes.add( SWC_SOMA );
		swcTypes.add( SWC_AXON );
		swcTypes.add( SWC_DENDRITE );
		swcTypes.add( SWC_APICAL_DENDRITE );
		// swcTypes.add(SWC_FORK_POINT);
		// swcTypes.add(SWC_END_POINT);
		swcTypes.add( SWC_CUSTOM );
		return swcTypes;
	}

	/**
	 * Gets the SWC type label associated with the specified type flag. SNT
	 * follows the specification detailed at <a href=
	 * "http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html">neuronland</a>
	 *
	 * @param type
	 *            the SWC type flag
	 * @param capitalized
	 *            whether output String should be capitalized
	 * @return the respective label, or {@link Path#SWC_UNDEFINED_LABEL} if flag
	 *         was not recognized
	 */
	public static String getSWCtypeName( final int type,
			final boolean capitalized )
	{
		String typeName;
		switch ( type )
		{
		case SWC_UNDEFINED:
			typeName = SWC_UNDEFINED_LABEL;
			break;
		case SWC_SOMA:
			typeName = SWC_SOMA_LABEL;
			break;
		case SWC_AXON:
			typeName = SWC_AXON_LABEL;
			break;
		case SWC_DENDRITE:
			typeName = SWC_DENDRITE_LABEL;
			break;
		case SWC_APICAL_DENDRITE:
			typeName = SWC_APICAL_DENDRITE_LABEL;
			break;
		case SWC_FORK_POINT:
			typeName = SWC_FORK_POINT_LABEL;
			break;
		case SWC_END_POINT:
			typeName = SWC_END_POINT_LABEL;
			break;
		case SWC_CUSTOM:
			typeName = SWC_CUSTOM_LABEL;
			break;
		default:
			typeName = SWC_UNDEFINED_LABEL;
			break;
		}
		if ( !capitalized )
			return typeName;

		final char[] buffer = typeName.toCharArray();
		boolean capitalizeNext = true;
		for ( int i = 0; i < buffer.length; i++ )
		{
			final char ch = buffer[ i ];
			if ( Character.isWhitespace( ch ) || !Character.isLetter( ch ) )
			{
				capitalizeNext = true;
			}
			else if ( capitalizeNext )
			{
				buffer[ i ] = Character.toTitleCase( ch );
				capitalizeNext = false;
			}
		}
		return new String( buffer );
	}

	/**
	 * Gets the path mean radius.
	 *
	 * @return the average radius of the path, or zero if path has no defined
	 *         thickness
	 * @see #hasRadii()
	 */
	public double getMeanRadius()
	{
		return ( hasRadii() ) ? StatUtils.mean( radii ) : 0;
	}

	/**
	 * Gets the radius of the specified node.
	 *
	 * @param pos
	 *            the node position
	 * @return the radius at the specified position, or zero if path has no
	 *         defined thickness
	 */
	public double getNodeRadius( final int pos )
	{
		if ( radii == null )
			return 0;
		if ( ( pos < 0 ) || pos >= size() )
		{ throw new IllegalArgumentException(
				"getNodeRadius() was asked for an out-of-range point: " + pos ); }
		return radii[ pos ];
	}

	/**
	 * Checks whether the nodes of this path have been assigned defined
	 * thickness.
	 *
	 * @return true, if the points defining with this path are associated with a
	 *         list of radii
	 */
	public boolean hasRadii()
	{
		return radii != null;
	}

	protected void setFittedCircles( final int nPoints, final double[] tangents_x,
			final double[] tangents_y, final double[] tangents_z,
			final double[] radii, final double[] optimized_x,
			final double[] optimized_y, final double[] optimized_z )
	{

		this.points = nPoints;
		if ( tangents_x != null )
			this.tangents_x = tangents_x.clone();
		if ( tangents_x != null )
			this.tangents_y = tangents_y.clone();
		if ( tangents_x != null )
			this.tangents_z = tangents_z.clone();
		if ( radii != null )
			this.radii = radii.clone();

		this.precise_x_positions = optimized_x.clone();
		this.precise_y_positions = optimized_y.clone();
		this.precise_z_positions = optimized_z.clone();
	}

	public String realToString()
	{
		String name = getName();
		if ( name == null )
			name = "Path " + getID();
		if ( size() == 1 )
			name += " [Single Point]";
//		if (startJoins != null) {
//			name += ", starts on " + startJoins.getName();
//		}
//		if (endJoins != null) {
//			name += ", ends on " + endJoins.getName();
//		}
		if ( swcType != SWC_UNDEFINED )
			name += " [" + getSWCtypeName( swcType,
					false ) + "]";
		return name;
	}

	/**
	 * This toString() method shows details of the path which is actually being
	 * displayed, not necessarily this path object.
	 *
	 * @return the string
	 */
	@Override
	public String toString()
	{ // FIXME: this is probably horribly confusing.
		if ( useFitted )
			return getFitted().realToString();
		return realToString();
	}

	/**
	 * Sets the SWC type.
	 *
	 * @param newSWCType
	 *            the new SWC type
	 */
	public void setSWCType( final int newSWCType )
	{
		setSWCType( newSWCType, true );
	}

	protected void setSWCType( final int newSWCType,
			final boolean alsoSetInFittedVersion )
	{
		if ( newSWCType < 0 )
			throw new IllegalArgumentException(
					"BUG: Unknown SWC type " + newSWCType );
		swcType = newSWCType;
		if ( alsoSetInFittedVersion )
		{
			/*
			 * If we've been asked to also set the fitted version, this should
			 * only be called on the non-fitted version of the path, so raise an
			 * error if it's been called on the fitted version by mistake
			 * instead:
			 */
			if ( isFittedVersionOfAnotherPath() && fittedVersionOf
					.getSWCType() != newSWCType )
				throw new IllegalArgumentException(
						"BUG: only call setSWCType on the unfitted path" );
			if ( getFitted() != null )
				getFitted().setSWCType( newSWCType );
		}
	}

	/**
	 * Gets the SWC type.
	 *
	 * @return the SWC type
	 */
	public int getSWCType()
	{
		return swcType;
	}

	/*
	 * @Override public String toString() { int n = size(); String result = "";
	 * if( name != null ) result += "\"" + name + "\" "; result += n +
	 * " points"; if( n > 0 ) { result += " from " + x_positions[0] + ", " +
	 * y_positions[0] + ", " + z_positions[0]; result += " to " +
	 * x_positions[n-1] + ", " + y_positions[n-1] + ", " + z_positions[n-1]; }
	 * return result; }
	 */

	/**
	 * Gets the "bifurcation" (branching) order of this Path. If registered in
	 * the GUI, this would correspond to the level of this Path in
	 * {@link PathManagerUI}'s JTree: E.g., a Path connected to a primary Path
	 * (order 1) will be assigned order 2, etc.. N.B.: Albeit related to reverse
	 * Horton-Strahler classification, Path ordering is formally distinct, as it
	 * classifies <i>Paths</i> instead of <i>branches</i>.
	 *
	 * @return the order of this path. A primary path is always of order 1.
	 * @see sc.fiji.snt.analysis.StrahlerAnalyzer
	 */
	public int getOrder()
	{
		return order;
	}

	public void setOrder( final int order )
	{
		this.order = order;
		if ( getFitted() != null )
			getFitted().order = order;
		else if ( fittedVersionOf != null )
			fittedVersionOf.order = order;
	}

	public void setSelected( final boolean newSelectedStatus )
	{
		selected = newSelectedStatus;
	}

	public boolean isSelected()
	{
		return selected;
	}

	// TODO: this should be renamed
	public boolean versionInUse()
	{
		if ( fittedVersionOf != null )
			return fittedVersionOf.useFitted;
		return !useFitted;
	}

	/**
	 * Returns an estimated volume of this path.
	 * <p>
	 * The most accurate volume of each path segment would be the volume of a
	 * convex hull of two arbitrarily oriented and sized circles in space. This
	 * is tough to work out analytically, and this precision isn't really
	 * warranted given the errors introduced in the fitting process, the tracing
	 * in the first place, etc. So, this method produces an approximate volume
	 * assuming that the volume of each of these parts is that of a truncated
	 * cone (Frustum) , with circles of the same size (i.e., as if the circles
	 * had simply been reoriented to be parallel and have a common normal
	 * vector)
	 * </p>
	 * <p>
	 * For more accurate measurements of the volumes of a neuron, you should use
	 * the filling interface.
	 * </p>
	 *
	 * @return the approximate fitted volume (in physical units), or 0 if this
	 *         Path has no radii
	 * @see #hasRadii()
	 */
	public double getApproximatedVolume()
	{
		if ( !hasRadii() )
		{ return 0; }

		double totalVolume = 0;
		for ( int i = 0; i < points - 1; ++i )
		{
			final double xdiff = precise_x_positions[ i + 1 ] - precise_x_positions[ i ];
			final double ydiff = precise_y_positions[ i + 1 ] - precise_y_positions[ i ];
			final double zdiff = precise_z_positions[ i + 1 ] - precise_z_positions[ i ];
			final double h = Math.sqrt( xdiff * xdiff + ydiff * ydiff + zdiff * zdiff );
			final double r1 = radii[ i ];
			final double r2 = radii[ i + 1 ];
			// See http://en.wikipedia.org/wiki/Frustum
			final double partVolume = ( Math.PI * h * ( r1 * r1 + r2 * r2 + r1 * r2 ) ) /
					3.0;
			totalVolume += partVolume;
		}

		return totalVolume;
	}

	/*
	 * This doesn't deal with the startJoins, endJoins or fitted fields, since
	 * they involve other paths which were probably also transformed by the
	 * caller.
	 */

	public Path transform( final PathTransformer transformation,
			final ImagePlus template, final ImagePlus model )
	{

		double templatePixelWidth = 1;
		double templatePixelHeight = 1;
		double templatePixelDepth = 1;
		String templateUnits = "pixels";

		final Calibration templateCalibration = template.getCalibration();
		if ( templateCalibration != null )
		{
			templatePixelWidth = templateCalibration.pixelWidth;
			templatePixelHeight = templateCalibration.pixelHeight;
			templatePixelDepth = templateCalibration.pixelDepth;
			templateUnits = templateCalibration.getUnit();
		}

		final Path result = new Path( templatePixelWidth, templatePixelHeight,
				templatePixelDepth, templateUnits, size() );
		final double[] transformed = new double[ 3 ];

		// Actually, just say you'll have to refit all the
		// previously fitted paths...

		for ( int i = 0; i < points; ++i )
		{
			final double original_x = precise_x_positions[ i ];
			final double original_y = precise_y_positions[ i ];
			final double original_z = precise_z_positions[ i ];
			transformation.transformPoint( original_x, original_y, original_z,
					transformed );
			final double new_x = transformed[ 0 ];
			final double new_y = transformed[ 1 ];
			final double new_z = transformed[ 2 ];
			if ( Double.isNaN( new_x ) || Double.isNaN( new_y ) || Double.isNaN( new_z ) )
				continue;
			result.addPointDouble( new_x, new_y, new_z );
		}

		result.id = id;
		result.selected = selected;
		result.name = name;

		result.x_spacing = x_spacing;
		result.y_spacing = y_spacing;
		result.z_spacing = z_spacing;
		result.spacing_units = spacing_units;

		result.swcType = swcType;

		return result;
	}

	/**
	 * Returns the nodes which are indicated to be a join (junction/branch
	 * point), either in this Path object, or any other that starts or ends on
	 * it.
	 *
	 * @return the list of nodes as {@link PointInImage} objects
	 * @see #findJunctionIndices()
	 * @see #getJunctionNodes()
	 */
	public List< PointInImage > findJunctions()
	{
		final ArrayList< PointInImage > result = new ArrayList<>();
		if ( startJoinsPoint != null )
		{
			result.add( startJoinsPoint );
		}
		if ( endJoinsPoint != null )
		{
			result.add( endJoinsPoint );
		}
		for ( final Path other : somehowJoins )
		{
			if ( other.startJoins == this )
			{
				result.add( other.startJoinsPoint );
			}
			if ( other.endJoins == this )
			{
				result.add( other.endJoinsPoint );
			}
		}
		return result;
	}

	/**
	 * This is a version of {@link #findJunctions()} ensuring that a junction
	 * node is only retrieved once even if multiple child paths are associated
	 * with it.
	 * 
	 * @see #findJunctionIndices()
	 * @return the junction nodes
	 */
	public Set< PointInImage > getJunctionNodes()
	{
		class LocationBasePoint extends PointInImage
		{
			LocationBasePoint( final PointInImage pim )
			{
				super( pim.x, pim.y, pim.z, pim.onPath );
			}

			@Override
			public boolean equals( final Object o )
			{
				if ( o == this )
					return true;
				if ( o == null )
					return false;
				if ( !( o instanceof PointInImage ) )
					return false;
				final PointInImage other = ( PointInImage ) o;
				return isSameLocation( other );
			}
		}
		final Set< PointInImage > result = new HashSet<>();
		findJunctions().forEach( j -> result.add( new LocationBasePoint( j ) ) );
		return result;
	}

	/**
	 * Returns the indices of nodes which are indicated to be a join, either in
	 * this Path object, or any other that starts or ends on it.
	 *
	 * @return the indices of junction nodes, naturally sorted
	 * @see #findJunctions()
	 * @see #getJunctionNodes()
	 */
	public TreeSet< Integer > findJunctionIndices()
	{
		final TreeSet< Integer > result = new TreeSet<>();
		for ( final PointInImage point : findJunctions() )
		{
			result.add( indexNearestTo( point.x, point.y, point.z ) );
		}
		return result;
	}

	/**
	 * Assigns a fixed radius to all the nodes of this Path
	 *
	 * @param r
	 *            the radius to be assigned. Setting it to 0 or Double.NaN
	 *            removes the radius attribute from the Path
	 */
	public void setRadius( final double r )
	{
		if ( Double.isNaN( r ) || r == 0d )
		{
			radii = null;
		}
		else
		{
			if ( radii == null )
			{
				createCircles();
				setGuessedTangents( 2 );
			}
			Arrays.fill( radii, r );
		}
	}

	/**
	 * Assigns radii to this Path
	 *
	 * @param radii
	 *            the radii array. Setting it null removes the radius attribute
	 *            from the Path
	 * @see #setRadius(double)
	 */
	public void setRadii( final double[] radii )
	{
		if ( radii == null || radii.length == 0 )
		{
			this.radii = null;
		}
		else if ( radii != null && radii.length != size() )
		{
			throw new IllegalArgumentException(
					"radii array must have as many elements as nodes" );
		}
		else
		{
			if ( this.radii == null )
			{
				createCircles();
				setGuessedTangents( 2 );
			}
			System.arraycopy( radii, 0, this.radii, 0, size() );
		}
	}

	public boolean isConnectedTo( final Path other )
	{
		return ( getStartJoins() != null && getStartJoins().equals( other ) )
				|| ( getEndJoins() != null && getEndJoins().equals( other ) )
				|| ( somehowJoins != null && somehowJoins.contains( other ) );
	}
}
